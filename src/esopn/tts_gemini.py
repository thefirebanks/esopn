"""Gemini TTS provider for ESOPN commentary - FREE multi-speaker TTS."""

import logging
from dataclasses import dataclass
from typing import Optional

import numpy as np
from google import genai
from google.genai import types

logger = logging.getLogger(__name__)

# Default voice configurations for the two commentators
# See: https://ai.google.dev/gemini-api/docs/speech-generation
DEFAULT_VOICES = {
    "alex": "Kore",      # Bold, confident - lead play-by-play energy
    "morgan": "Charon",  # Deep, authoritative - color commentary veteran
}

# Alternative voice options:
# Bold/Confident: Kore, Fenrir, Orus
# Deep/Authoritative: Charon, Orus, Fenrir
# Energetic: Puck, Fenrir, Laomedeia


@dataclass
class GeminiAudio:
    """Container for synthesized audio from Gemini."""

    audio: np.ndarray
    sample_rate: int
    duration: float
    text: str


class GeminiTTS:
    """Gemini TTS client for dual-speaker commentary.
    
    Uses Gemini's native multi-speaker TTS which supports [S1] and [S2] tags
    directly - perfect match for our dialogue format!
    """

    def __init__(
        self,
        api_key: str,
        alex_voice: Optional[str] = None,
        morgan_voice: Optional[str] = None,
        model: str = "gemini-2.5-flash-preview-tts",
    ):
        """
        Initialize Gemini TTS.

        Args:
            api_key: Google Gemini API key
            alex_voice: Voice name for Alex (S1). Uses default if None.
            morgan_voice: Voice name for Morgan (S2). Uses default if None.
            model: Gemini model to use for TTS
        """
        self.client = genai.Client(api_key=api_key)
        self.alex_voice = alex_voice or DEFAULT_VOICES["alex"]
        self.morgan_voice = morgan_voice or DEFAULT_VOICES["morgan"]
        self.model = model
        self.sample_rate = 24000  # Gemini outputs at 24kHz

    def synthesize_dialogue(self, dialogue: str) -> GeminiAudio:
        """
        Synthesize dialogue with [S1] and [S2] speaker tags.

        [S1] = Alex (play-by-play)
        [S2] = Morgan (color commentary)

        Args:
            dialogue: Text with [S1] and [S2] tags

        Returns:
            GeminiAudio with synthesized audio
        """
        # Ensure dialogue has proper speaker tags
        if "[S1]" not in dialogue and "[S2]" not in dialogue:
            dialogue = f"[S1] {dialogue}"

        logger.debug(f"Synthesizing with Gemini: {dialogue[:100]}...")

        # Retry logic for transient API errors
        max_retries = 3
        last_error = None
        
        for attempt in range(max_retries):
            try:
                response = self.client.models.generate_content(
                    model=self.model,
                    contents=dialogue,
                    config=types.GenerateContentConfig(
                        response_modalities=["AUDIO"],
                        speech_config=types.SpeechConfig(
                            multi_speaker_voice_config=types.MultiSpeakerVoiceConfig(
                                speaker_voice_configs=[
                                    types.SpeakerVoiceConfig(
                                        speaker="S1",
                                        voice_config=types.VoiceConfig(
                                            prebuilt_voice_config=types.PrebuiltVoiceConfig(
                                                voice_name=self.alex_voice
                                            )
                                        ),
                                    ),
                                    types.SpeakerVoiceConfig(
                                        speaker="S2",
                                        voice_config=types.VoiceConfig(
                                            prebuilt_voice_config=types.PrebuiltVoiceConfig(
                                                voice_name=self.morgan_voice
                                            )
                                        ),
                                    ),
                                ]
                            )
                        ),
                    ),
                )

                # Extract audio data from response
                if not response.candidates or not response.candidates[0].content.parts:
                    raise RuntimeError("No audio generated by Gemini")

                part = response.candidates[0].content.parts[0]
                if not hasattr(part, "inline_data") or part.inline_data is None:
                    raise RuntimeError("Response does not contain audio data")

                # Convert PCM L16 (16-bit signed little-endian) to float32
                audio_bytes = part.inline_data.data
                audio = np.frombuffer(audio_bytes, dtype=np.int16).astype(np.float32) / 32768.0

                duration = len(audio) / self.sample_rate

                logger.debug(f"Generated {duration:.2f}s of audio")

                return GeminiAudio(
                    audio=audio,
                    sample_rate=self.sample_rate,
                    duration=duration,
                    text=dialogue,
                )

            except Exception as e:
                last_error = e
                error_str = str(e)
                # Retry on 500/503 errors (transient server issues)
                if "500" in error_str or "503" in error_str or "INTERNAL" in error_str:
                    if attempt < max_retries - 1:
                        wait_time = (attempt + 1) * 1.0  # 1s, 2s, 3s
                        logger.warning(f"Gemini TTS failed (attempt {attempt + 1}/{max_retries}), retrying in {wait_time}s...")
                        import time
                        time.sleep(wait_time)
                        continue
                # Non-retryable error, raise immediately
                logger.error(f"Gemini TTS failed: {e}")
                raise
        
        # All retries exhausted
        logger.error(f"Gemini TTS failed after {max_retries} attempts: {last_error}")
        raise last_error

    def synthesize_single(
        self,
        text: str,
        voice: Optional[str] = None,
    ) -> GeminiAudio:
        """
        Synthesize a single piece of text with one voice.

        Args:
            text: Text to synthesize
            voice: Voice name (defaults to Alex's voice)

        Returns:
            GeminiAudio with synthesized audio
        """
        voice = voice or self.alex_voice

        logger.debug(f"Synthesizing single voice ({voice}): {text[:50]}...")

        try:
            response = self.client.models.generate_content(
                model=self.model,
                contents=text,
                config=types.GenerateContentConfig(
                    response_modalities=["AUDIO"],
                    speech_config=types.SpeechConfig(
                        voice_config=types.VoiceConfig(
                            prebuilt_voice_config=types.PrebuiltVoiceConfig(
                                voice_name=voice
                            )
                        )
                    ),
                ),
            )

            # Extract audio data
            part = response.candidates[0].content.parts[0]
            audio_bytes = part.inline_data.data
            audio = np.frombuffer(audio_bytes, dtype=np.int16).astype(np.float32) / 32768.0

            duration = len(audio) / self.sample_rate

            return GeminiAudio(
                audio=audio,
                sample_rate=self.sample_rate,
                duration=duration,
                text=text,
            )

        except Exception as e:
            logger.error(f"Gemini TTS (single) failed: {e}")
            raise
